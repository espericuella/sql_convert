import os

from constants import db_user, db_owner
from sql_convert.interfaces.interfaces import FieldDefinition
from sql_convert.common import is_string

header = '-- Generated by sql-convert.py \n-- Library created by Potapenko<vp@nsg.ovh> \n'


# SQL functions GET, DELETE, LIST, SAVE create
def get_function_list(arr: list) -> str:
    field_list = ''
    for item in arr:
        field_list += f'          {item["field"]},\n'
    return field_list[0:-2]


def get_field_array(arr: list) -> str:
    result = ''
    for item in arr:
        if is_string(item):
            if result != '':
                result += ','
            result += '"' + item["field"] + '"'
    return result


def sql_data(elem: FieldDefinition) -> str:
    match elem['type']:
        case 'BOOLEAN' | 'BOOL':
            return f'COALESCE( cast( f_data->>' + elem['field'] + ' as boolean), true)'
        case 'DATE' | 'TIMESTAMP' | 'TIMESTAMPZ' | 'INT4' | 'INT8' | 'INTEGER':
            return f'CAST( f_data->>' + elem['field'] + ' as ${elem.type})'
        case 'VARCHAR' | 'BPCHAR':
            return 'f_data->>' + elem['field']
        case _:
            return 'f_data->>' + elem['field']


def generate_get(schema_name: str, tbl_name: str, sequence_name: str, field_array: list):
    # GET
    get_fnc_name = f'{schema_name}.{tbl_name}_get'
    if schema_name == 'public':
        get_fnc_name = f'{tbl_name}_get'

    sql_get = f"""{header}
CREATE OR REPLACE FUNCTION {get_fnc_name}( a_id integer )
  RETURNS TEXT AS
$BODY$
BEGIN
  PERFORM 1 FROM {schema_name}.{tbl_name} WHERE {field_array[0]["field"]} = a_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', '{tbl_name.capitalize()} do not exists', 'code', 404);
  END IF;
  
  RETURN to_jsonb( u ) FROM (
    SELECT
{get_function_list(field_array)} 
     FROM {schema_name}.{tbl_name}
    WHERE {field_array[0]["field"]} = a_id
  ) as u;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
                   COST 100;
COMMENT ON FUNCTION {get_fnc_name}(integer) IS 'Get {tbl_name}';
ALTER FUNCTION {get_fnc_name}(integer) OWNER TO {db_owner};
GRANT EXECUTE ON FUNCTION {get_fnc_name}(integer) TO {db_user};"""
    file_path = os.path.join('dist', 'sql', f'fnc_{get_fnc_name}.sql')
    os.makedirs(os.path.join('dist', 'sql'), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(sql_get)


def generate_delete(schema_name: str, tbl_name: str, sequence_name: str, field_array: list):
    # DELETE
    del_fnc_name = f'{schema_name}.{tbl_name}_delete'
    if schema_name == 'public':
        del_fnc_name = f'{tbl_name}_delete'

    sql_delete = f"""{header}
CREATE OR REPLACE FUNCTION {del_fnc_name} ( a_id integer )
  RETURNS TEXT AS
$BODY$
BEGIN
  PERFORM 1 FROM {schema_name}.{tbl_name} WHERE {field_array[0]["field"]} = a_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', '{tbl_name.capitalize()} do not exists', 'code', 404);
  END IF;

  BEGIN
    DELETE FROM {schema_name}.{tbl_name} WHERE {field_array[0]["field"]} = a_id;
  EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('error', 'Cannot delete current {tbl_name.lower()}', 'code', 403);
  END;
  RETURN jsonb_build_object('code', 202 );
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
                   COST 100;
COMMENT ON FUNCTION {del_fnc_name}(integer) IS 'Delete {tbl_name}';
ALTER FUNCTION {del_fnc_name}(integer) OWNER TO {db_owner};
GRANT EXECUTE ON FUNCTION {del_fnc_name}(integer) TO {db_user};"""
    file_path = os.path.join('dist', 'sql', f'fnc_{del_fnc_name}.sql')
    os.makedirs(os.path.join('dist', 'sql'), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(sql_delete)


def generate_search(schema_name: str, tbl_name: str, sequence_name: str, field_array: list):
    # SEARCH
    search_fnc_name = f'{schema_name}.{tbl_name}_search'
    if schema_name == 'public':
        search_fnc_name = f'{tbl_name}_search'

    sql_search = f"""{header}
CREATE OR  REPLACE FUNCTION {search_fnc_name}( a_filter character varying )
  RETURNS TEXT AS
$BODY$
DECLARE
  f_request   jsonb;
  f_filter    jsonb; -- "filter":[{{"field": "login", "value": "John%"}}]
  f_p_size    integer;
  f_p_offset  integer;
  f_order     varchar;  -- asc/desc
  f_sort      varchar; -- "sort": ["login", "active"]
  f_sql       varchar;
  f_result    jsonb;
  f_cnt       integer;
  f_sql_where varchar;
  f_sql_order varchar;
  f_valid_search_fields varchar[];
  f_filter_field_type varchar;
BEGIN
  f_valid_search_fields = '{{{get_field_array(field_array)}}}'::varchar[];
  f_request = CAST(a_filter as jsonb);
  f_p_size = (f_request->>'page_size')::integer;
  f_p_offset = (f_request->>'page_index')::integer * f_p_size;
  f_order = f_request->>'sort_direction';
  IF (NOT ((f_order='asc') OR (f_order='desc') OR (f_order=''))) THEN
    RETURN jsonb_build_object('error','Wrong order', 'code', 400);
  END IF;
  f_sql_where = '';
  FOR f_filter IN
    SELECT * FROM jsonb_array_elements( f_request->'filter' )
  LOOP
    IF NOT CAST(f_filter->>'field' as varchar) = ANY (f_valid_search_fields) THEN
      RETURN jsonb_build_object('error','Wrong filter field', 'code', 400);
    END IF;
    SELECT data_type
      INTO f_filter_field_type
      FROM information_schema.columns
     WHERE table_name = '{tbl_name}'
       AND table_schema = '{schema_name}'
       AND column_name = CAST(f_filter->>'field' as varchar);
    IF f_filter_field_type = 'character varying' THEN
      f_sql_where = f_sql_where || ' AND upper(' || CAST(f_filter->>'field' as varchar) || ') LIKE ' || quote_literal(upper(f_filter->>'value'));
    ELSEIF f_filter_field_type = 'boolean' THEN
      f_sql_where = f_sql_where || ' AND ' || CAST(f_filter->>'field' as varchar) || ' = ' || CAST(f_filter->>'value' as varchar);
    ELSE
      RETURN jsonb_build_object('error','Wrong filter field type', 'code', 400);
    END IF;
  END LOOP;
  f_sql_order = '';
  FOR f_sort IN
    SELECT * FROM jsonb_array_elements_text( f_request->'sort')
  LOOP
    IF NOT CAST(f_sort as varchar) = ANY (f_valid_search_fields) THEN
      RETURN jsonb_build_object('error','Wrong sort field', 'code', 400);
    END IF;
    IF (f_sql_order = ''::varchar) THEN
      f_sql_order = f_sql_order || f_sort;
    ELSE
      f_sql_order = f_sql_order || ',' || f_sort;
    END IF;
  END LOOP;
  IF (f_sql_order <> '') THEN
    f_sql_order = ' ORDER BY ' || f_sql_order || ' ' || f_order;
  END IF;
   f_sql = format('SELECT COALESCE(to_jsonb(array_agg( {tbl_name[0]} )),''[]''::jsonb) FROM (
    SELECT
{get_function_list(field_array)}
    FROM {schema_name}.{tbl_name}
    WHERE TRUE %s
    %s
    LIMIT $1
    OFFSET $2
  ) as {tbl_name[0]}', f_sql_where, f_sql_order);
  EXECUTE f_sql INTO f_result USING f_p_size, f_p_offset;
  SELECT COUNT(*) INTO f_cnt FROM jsonb_array_elements(f_result);
  RETURN jsonb_build_object('data', f_result, 'cnt', f_cnt);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
                   COST 100;
COMMENT ON FUNCTION {search_fnc_name}(character varying) IS '{tbl_name.capitalize()} list';
ALTER FUNCTION {search_fnc_name}(character varying) OWNER TO {db_owner};
GRANT EXECUTE ON FUNCTION {search_fnc_name}(character varying) TO {db_user};"""
    file_path = os.path.join('dist', 'sql', f'fnc_{search_fnc_name}.sql')
    os.makedirs(os.path.join('dist', 'sql'), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(sql_search)


def generate_save(schema_name: str, tbl_name: str, sequence_name: str, field_array: list):
    # SAVE
    save_fnc_name = f'{schema_name}.{tbl_name}_save'
    if schema_name == 'public':
        save_fnc_name = f'{tbl_name}_save'

    sql_save = f"""{header}
CREATE OR REPLACE FUNCTION {save_fnc_name}( a_data character varying )
    RETURNS text AS
$BODY$
DECLARE
  f_id    integer;
  f_data  jsonb;
BEGIN
  f_data = a_data::jsonb;
  f_id   = COALESCE( CAST( f_data->>'{field_array[0]["field"]}' as INTEGER ), 0);
  IF f_id > 0 THEN
      PERFORM 1 FROM {schema_name}.{tbl_name} WHERE {field_array[0]["field"]} = f_id;
      IF NOT FOUND THEN
        RETURN jsonb_build_object('error', '{tbl_name.capitalize()} do not exists', 'code', 404);
      END IF;
      UPDATE {schema_name}.{tbl_name} SET \n"""

    for item in field_array:
        if item["field"] == field_array[0]["field"]:
            continue
        sql_save += f'            {item["field"]} = {sql_data(item)},\n'

    sql_save = sql_save[0:-2]
    sql_save += f"""
    WHERE {field_array[0]["field"]} = f_id;
  ELSE
      f_id = nextval('{sequence_name}'::regclass);
      INSERT INTO {schema_name}.{tbl_name} (
{get_function_list(field_array)}
      ) VALUES (
          f_id,\n"""

    # Copy and remove first element (id), already filled as f_id
    insert_array = list(field_array)
    insert_array.pop(0)

    for item in insert_array:
        sql_save += f'          {sql_data(item)},\n'

    sql_save = sql_save[0:-2]
    sql_save += f"""
    );
  END IF;
  RETURN jsonb_build_object('id', f_id, 'code', 200 );
END;
$BODY$
    LANGUAGE plpgsql VOLATILE
                     COST 100;
ALTER FUNCTION {save_fnc_name}(character varying) OWNER TO {db_owner};
GRANT EXECUTE ON FUNCTION {save_fnc_name}(character varying) TO {db_user};"""
    file_path = os.path.join('dist', 'sql', f'fnc_{save_fnc_name}.sql')
    os.makedirs(os.path.join('dist', 'sql'), exist_ok=True)
    with open(file_path, 'w') as file:
        file.write(sql_save)


def generate_sql(schema_name: str, tbl_name: str, sequence_name: str, field_array: list):
    generate_get(schema_name, tbl_name, sequence_name, field_array)

    generate_delete(schema_name, tbl_name, sequence_name, field_array)

    generate_save(schema_name, tbl_name, sequence_name, field_array)

    generate_search(schema_name, tbl_name, sequence_name, field_array)
